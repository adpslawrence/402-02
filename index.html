<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¥µé€Ÿå±…å®¶è³½è»ŠæŒ‘æˆ° - ç”Ÿå‘½å€¼ä¿®æ­£ç‰ˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        
        .game-container {
            position: relative;
            background-color: #e0d8c0;
            border: 8px solid #8b4513;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), inset 0 0 10px rgba(255, 255, 255, 0.5);
            border-radius: 12px;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            text-align: center;
            z-index: 10;
        }

        .ui-title {
            font-size: 2.5rem;
            font-weight: 900;
            color: #ffaa00;
            text-shadow: 0 0 10px rgba(255, 170, 0, 0.7);
            margin-bottom: 20px;
        }

        .ui-button {
            padding: 12px 24px;
            font-size: 1.25rem;
            font-weight: 700;
            color: #1a1a1a;
            background: linear-gradient(145deg, #ffda47, #ff9900);
            border: 2px solid #ffda47;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px #cc7a00, 0 0 15px rgba(255, 153, 0, 0.6);
        }
        
        .win-button {
            background: linear-gradient(145deg, #00ff99, #00b36e);
            border: 2px solid #00ff99;
            box-shadow: 0 4px #00b36e, 0 0 15px rgba(0, 255, 153, 0.6);
        }

        .score-board {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            color: #1a1a1a;
            font-size: 1.1rem;
            font-weight: 700;
            text-shadow: 0 0 5px #fff;
            z-index: 5;
            padding: 0 10px;
        }

        .level-display {
             color: #8b4513;
             text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
        
        .rank-display {
            font-size: 1.5rem;
            font-weight: 900;
            color: #fdd835;
            text-shadow: 0 0 5px #ffeb3b;
        }

        .speed-line {
            position: absolute;
            width: 2px;
            background-color: rgba(255, 255, 255, 0.5);
            height: 20px;
            opacity: 0;
            animation: speedLineFlow 0.5s linear infinite; 
        }
        @keyframes speedLineFlow {
            0% { transform: translateY(-20px); opacity: 0; }
            5% { opacity: 0.8; }
            100% { transform: translateY(600px); opacity: 0; }
        }
    </style>
</head>
<body>

<div class="game-container" id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    
    <div class="score-board">
        <div id="healthDisplay">ç”Ÿå‘½: â¤ï¸â¤ï¸â¤ï¸</div>
        <div id="levelDisplay" class="level-display">é—œå¡: 1</div>
        <div id="rankDisplay" class="rank-display">åæ¬¡: 3/3</div>
        <div id="scoreDisplay">è·é›¢: 0m</div>
    </div>

    <div class="ui-overlay" id="menuScreen">
        <div class="ui-title">æ¥µé€Ÿå±…å®¶è³½è»ŠæŒ‘æˆ°</div>
        <div class="text-white mb-4">é§•é§›è³½è»Š (ğŸï¸)ï¼Œåœ¨ 5 å€‹é—œå¡ä¸­é–ƒèº²éšœç¤™ç‰© (ğŸ›‹ï¸, ğŸ§¸) ä¸¦æ“Šæ•—å°æ‰‹ (ğŸš—, ğŸš“)ã€‚<br>æ–¹å‘éµæ§åˆ¶å·¦å³ï¼Œç›®æ¨™æ˜¯è´å¾—ç¬¬ä¸€åï¼</div>
        <button class="ui-button" id="startButton">é–‹å§‹æ¯”è³½</button>
    </div>

    <div class="ui-overlay hidden" id="levelWinScreen">
        <div class="ui-title">æª¢æŸ¥é»é”æˆ!</div>
        <div class="text-white mb-4" id="levelCompleteText">æ‚¨æˆåŠŸè·‘å®Œç¬¬ 1 é—œ!</div>
        <button class="ui-button win-button" id="nextLevelButton">é€²å…¥ä¸‹ä¸€é—œ</button>
    </div>

    <div class="ui-overlay hidden" id="gameOverScreen">
        <div class="ui-title">æ¯”è³½çµæŸ!</div>
        <div class="text-red-400 text-xl mb-4" id="finalScoreText">æ‚¨çš„ç¸½è·é›¢: 0m</div>
        <button class="ui-button" id="restartButton">é‡æ–°é–‹å§‹</button>
    </div>
    
    <div class="ui-overlay hidden" id="gameCompleteScreen">
        <div class="ui-title">ğŸ† æ­å–œï¼è³½è»Šå† è»! ğŸ†</div>
        <div class="text-green-400 text-xl mb-4">æ‚¨å·²é€šé—œæ‰€æœ‰é—œå¡ï¼Œæˆç‚ºå±…å®¶æ¥µé€Ÿå† è»ï¼</div>
        <button class="ui-button win-button" id="playAgainButton">å†ç©ä¸€æ¬¡</button>
    </div>
</div>

<script>
    const CANVAS_WIDTH = 400;
    const CANVAS_HEIGHT = 600;
    const MAX_HEALTH = 3;
    let gameState = 'MENU'; 
    
    const OBJECT_BASE_SIZE = 40; 
    const TRACK_TOP_WIDTH = CANVAS_WIDTH * 0.35; 
    const TRACK_BOTTOM_WIDTH = CANVAS_WIDTH * 0.95; 
    
    const LEVELS = [
        { targetDistance: 800, initialSpeed: 4, initialRate: 90 },
        { targetDistance: 1800, initialSpeed: 5, initialRate: 80 },  
        { targetDistance: 3000, initialSpeed: 6, initialRate: 70 },  
        { targetDistance: 4500, initialSpeed: 7, initialRate: 60 },  
        { targetDistance: 6000, initialSpeed: 8, initialRate: 50 }
    ];
    let currentLevel = 1;

    let player = {
        x: CANVAS_WIDTH * 0.5, 
        y: CANVAS_HEIGHT - 80, 
        baseSize: OBJECT_BASE_SIZE * 0.9, 
        dx: 0,
        speed: 10,
        health: MAX_HEALTH,
        emoji: 'ğŸï¸'
    };
    
    const OPPONENTS_CONFIG = [
        { name: 'BlueCar', emoji: 'ğŸš—', baseSpeedMultiplier: 0.98, color: '#2196F3' }, 
        { name: 'PoliceCar', emoji: 'ğŸš“', baseSpeedMultiplier: 1.02, color: '#F44336' } 
    ];
    let competitors = []; 

    let obstacles = [];
    let collectibles = []; 
    let score = 0; 
    let levelScore = 0; 
    let gameSpeed = 1.0; 
    let obstacleInterval = 0; 
    let obstacleGenerationRate = 200; 
    let rank = 3; 

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const menuScreen = document.getElementById('menuScreen');
    const levelWinScreen = document.getElementById('levelWinScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const gameCompleteScreen = document.getElementById('gameCompleteScreen');
    
    const startButton = document.getElementById('startButton');
    const restartButton = document.getElementById('restartButton');
    const nextLevelButton = document.getElementById('nextLevelButton');
    const playAgainButton = document.getElementById('playAgainButton');
    
    const healthDisplay = document.getElementById('healthDisplay');
    const levelDisplay = document.getElementById('levelDisplay');
    const rankDisplay = document.getElementById('rankDisplay');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const finalScoreText = document.getElementById('finalScoreText');
    const levelCompleteText = document.getElementById('levelCompleteText');
    const gameContainer = document.getElementById('gameContainer');

    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;

    function getScaleFactor(y) {
        const minScale = 0.2;
        const maxScale = 1.0;
        const factor = y / CANVAS_HEIGHT;
        return minScale + factor * (maxScale - minScale);
    }
    
    function getPerspectiveProps(obj) {
        const scale = getScaleFactor(obj.y);
        const size = (obj.baseSize || OBJECT_BASE_SIZE) * scale;
        const trackWidthAtY = TRACK_TOP_WIDTH + (TRACK_BOTTOM_WIDTH - TRACK_TOP_WIDTH) * (obj.y / CANVAS_HEIGHT);
        const trackLeftEdgeAtY = (CANVAS_WIDTH - trackWidthAtY) / 2;
        const oldTrackStart = CANVAS_WIDTH * 0.1;
        const oldTrackWidth = CANVAS_WIDTH * 0.8;
        let normalizedX = (obj.x - oldTrackStart) / oldTrackWidth; 
        normalizedX = Math.max(0, Math.min(1, normalizedX)); 
        const perspectiveX = trackLeftEdgeAtY + normalizedX * trackWidthAtY - (size / 2);

        return {
            x: perspectiveX,
            y: obj.y - (size / 2),
            size: size,
            width: size,
            height: size
        };
    }

    function hideAllScreens() {
        menuScreen.classList.add('hidden');
        levelWinScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        gameCompleteScreen.classList.add('hidden');
    }

    // ä¿®æ­£ UI æ›´æ–°ï¼Œæ­£ç¢ºæ¸²æŸ“ç”Ÿå‘½å€¼åœ–æ¨™
    function updateUI() {
        const currentHealth = Math.max(0, Math.min(MAX_HEALTH, player.health));
        const hearts = 'â¤ï¸'.repeat(currentHealth) + 'ğŸ¤'.repeat(MAX_HEALTH - currentHealth);
        healthDisplay.textContent = `ç”Ÿå‘½: ${hearts}`;
        
        levelDisplay.textContent = `é—œå¡: ${currentLevel} / ${LEVELS.length}`; 
        const target = LEVELS[currentLevel - 1].targetDistance;
        const progress = Math.min(levelScore, target);
        scoreDisplay.textContent = `è·é›¢: ${Math.floor(progress)} / ${target}m`;
        rankDisplay.textContent = `åæ¬¡: ${rank} / ${competitors.length + 1}`;
        finalScoreText.textContent = `æ‚¨çš„ç¸½è·é›¢: ${Math.floor(score)}m`;
    }

    function initCompetitors() {
        competitors = OPPONENTS_CONFIG.map(config => ({
            ...config,
            levelScore: 0,
            x: CANVAS_WIDTH * (0.3 + Math.random() * 0.4),
            y: CANVAS_HEIGHT - 80,
            baseSize: OBJECT_BASE_SIZE * 0.9,
            aiMoveFactor: Math.random() * 0.05 + 0.01,
            aiMoveOffset: Math.random() * 100
        }));
    }

    function loadLevel(levelNum) {
        if (levelNum > LEVELS.length) {
            gameState = 'GAME_COMPLETE';
            hideAllScreens();
            gameCompleteScreen.classList.remove('hidden');
            return;
        }
        currentLevel = levelNum;
        const levelConfig = LEVELS[currentLevel - 1];
        player.x = CANVAS_WIDTH * 0.5; 
        initCompetitors();
        obstacles = [];
        collectibles = []; 
        levelScore = 0;
        gameSpeed = levelConfig.initialSpeed;
        obstacleGenerationRate = levelConfig.initialRate;
        gameState = 'PLAYING';
        createSpeedLine(60);
        hideAllScreens();
        updateUI();
    }

    // é‡ç½®éŠæˆ²æ™‚ç¢ºä¿ç”Ÿå‘½å€¼æ¢å¾©
    function resetGame() {
        player.health = MAX_HEALTH;
        score = 0;
        loadLevel(1);
    }

    function checkCollision(obj1Props, obj2Props) {
        const padding = 5; 
        return obj1Props.x + padding < obj2Props.x + obj2Props.width - padding &&
               obj1Props.x + obj1Props.width - padding > obj2Props.x + padding &&
               obj1Props.y + padding < obj2Props.y + obj2Props.height - padding &&
               obj1Props.y + obj2Props.height - padding > obj2Props.y + padding;
    }

    function createSpeedLine(count) {
        document.querySelectorAll('.speed-line').forEach(line => line.remove());
        for (let i = 0; i < count; i++) {
            const line = document.createElement('div');
            line.className = 'speed-line';
            const randomXOffset = Math.random() * (TRACK_BOTTOM_WIDTH - TRACK_TOP_WIDTH) + TRACK_TOP_WIDTH;
            const randomX = (CANVAS_WIDTH - randomXOffset) / 2 + Math.random() * randomXOffset;
            line.style.left = `${randomX}px`;
            line.style.top = `${Math.random() * CANVAS_HEIGHT}px`;
            line.style.animationDelay = `${-Math.random() * 1}s`;
            gameContainer.appendChild(line);
        }
    }

    function drawEmojiAt(emoji, x, y, size, rotationDegrees) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotationDegrees * Math.PI / 180);
        ctx.font = `${size}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(emoji, 0, 0);
        ctx.restore();
    }

    function drawPlayer() {
        const props = getPerspectiveProps(player); 
        drawEmojiAt(player.emoji, props.x + props.width / 2, props.y + props.height / 2, props.size, 90);
    }
    
    function drawOpponents() {
        competitors.forEach(opp => {
            const props = getPerspectiveProps(opp);
            drawEmojiAt(opp.emoji, props.x + props.width / 2, props.y + props.height / 2, props.size, 90);
        });
    }

    function drawObstacles() {
        obstacles.forEach(obs => {
            const props = getPerspectiveProps(obs); 
            ctx.font = `${props.size}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(obs.type === 'sofa' ? 'ğŸ›‹ï¸' : 'ğŸ§¸', props.x + props.width / 2, props.y + props.height / 2);
        });
    }

    function drawCollectibles() {
        collectibles.forEach(item => {
            const props = getPerspectiveProps(item); 
            ctx.font = `${props.size}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('â¤ï¸', props.x + props.width / 2, props.y + props.height / 2);
        });
    }

    function drawTrack() {
        ctx.fillStyle = '#d2b48c'; 
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        ctx.strokeStyle = '#8b4513';
        ctx.lineWidth = 5;
        ctx.fillStyle = '#c7ac92'; 
        const topL = (CANVAS_WIDTH - TRACK_TOP_WIDTH) / 2;
        const topR = (CANVAS_WIDTH + TRACK_TOP_WIDTH) / 2;
        const bottomL = (CANVAS_WIDTH - TRACK_BOTTOM_WIDTH) / 2;
        const bottomR = (CANVAS_WIDTH + TRACK_BOTTOM_WIDTH) / 2;
        ctx.beginPath();
        ctx.moveTo(topL, 0);
        ctx.lineTo(bottomL, CANVAS_HEIGHT);
        ctx.lineTo(bottomR, CANVAS_HEIGHT);
        ctx.lineTo(topR, 0);
        ctx.closePath();
        ctx.fill(); 
        ctx.stroke(); 
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.setLineDash([20, 15]);
        ctx.beginPath();
        ctx.moveTo(CANVAS_WIDTH / 2, 0);
        ctx.lineTo(CANVAS_WIDTH / 2, CANVAS_HEIGHT);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    function draw() {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        drawTrack();
        drawOpponents();
        drawObstacles();
        drawCollectibles();
        drawPlayer();
    }

    function updateRanking() {
        const allRacers = [
            { id: 'player', score: levelScore },
            ...competitors.map((c, index) => ({ id: `opp${index}`, score: c.levelScore }))
        ];
        allRacers.sort((a, b) => b.score - a.score);
        rank = allRacers.findIndex(r => r.id === 'player') + 1;
    }
    
    function updateOpponents() {
        const trackLeftLimit = CANVAS_WIDTH * 0.1;
        const trackRightLimit = CANVAS_WIDTH * 0.9;
        competitors.forEach(opp => {
            opp.levelScore += gameSpeed * opp.baseSpeedMultiplier * 0.05;
            const sineWave = Math.sin(Date.now() / 1000 + opp.aiMoveOffset) * opp.aiMoveFactor;
            const randomWander = (Math.random() - 0.5) * 0.2;
            opp.x += (sineWave + randomWander) * 10;
            opp.x = Math.max(trackLeftLimit, Math.min(opp.x, trackRightLimit));
        });
    }

    function update() {
        if (gameState !== 'PLAYING') return;

        player.x += player.dx;
        const trackLeftLimit = CANVAS_WIDTH * 0.1;
        const trackRightLimit = CANVAS_WIDTH * 0.9; 
        player.x = Math.max(trackLeftLimit, Math.min(player.x, trackRightLimit));

        const speedStep = gameSpeed * 0.05;
        score += speedStep; 
        levelScore += speedStep; 
        
        updateOpponents();
        updateRanking();
        
        if (levelScore >= LEVELS[currentLevel - 1].targetDistance) {
            gameState = 'LEVEL_WIN';
            document.querySelectorAll('.speed-line').forEach(line => line.remove()); 
            hideAllScreens();
            levelCompleteText.textContent = `æ‚¨æˆåŠŸè·‘å®Œç¬¬ ${currentLevel} é—œ! ç›®å‰æ’åç¬¬ ${rank} å!`;
            levelWinScreen.classList.remove('hidden');
            return;
        }

        obstacleInterval++;
        if (obstacleInterval >= obstacleGenerationRate) {
            obstacles.push({
                x: CANVAS_WIDTH * 0.1 + Math.random() * (CANVAS_WIDTH * 0.8),
                y: 0,
                baseSize: OBJECT_BASE_SIZE,
                type: Math.random() < 0.5 ? 'sofa' : 'toy'
            });
            obstacleInterval = 0;
            if (Math.random() < 0.2) {
                collectibles.push({
                    x: CANVAS_WIDTH * 0.1 + Math.random() * (CANVAS_WIDTH * 0.8),
                    y: 0,
                    baseSize: OBJECT_BASE_SIZE * 0.7,
                    type: 'heart'
                });
            }
        }

        const playerProps = getPerspectiveProps(player); 
        
        for (let i = obstacles.length - 1; i >= 0; i--) {
            const obs = obstacles[i];
            obs.y += gameSpeed;
            const obsProps = getPerspectiveProps(obs); 
            
            if (checkCollision(playerProps, obsProps)) {
                player.health = Math.max(0, player.health - 1);
                updateUI();
                obstacles.splice(i, 1); 
                canvas.style.transform = 'translate(4px, 4px)';
                setTimeout(() => canvas.style.transform = 'none', 100);

                if (player.health <= 0) {
                    gameState = 'GAME_OVER';
                    hideAllScreens();
                    gameOverScreen.classList.remove('hidden');
                }
            } else if (obs.y > CANVAS_HEIGHT) {
                obstacles.splice(i, 1);
            }
        }

        for (let i = collectibles.length - 1; i >= 0; i--) {
            const item = collectibles[i];
            item.y += gameSpeed; 
            const itemProps = getPerspectiveProps(item); 

            if (checkCollision(playerProps, itemProps)) {
                if (player.health < MAX_HEALTH) {
                    player.health++;
                    updateUI();
                }
                collectibles.splice(i, 1);
            } else if (item.y > CANVAS_HEIGHT) {
                collectibles.splice(i, 1);
            }
        }
        
        updateUI();
    }

    function gameLoop(timestamp) {
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }

    document.addEventListener('keydown', (e) => {
        if (gameState !== 'PLAYING') return;
        if (e.key === 'ArrowLeft' || e.key === 'a') player.dx = -player.speed;
        else if (e.key === 'ArrowRight' || e.key === 'd') player.dx = player.speed;
    });

    document.addEventListener('keyup', (e) => {
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'ArrowRight' || e.key === 'd') player.dx = 0;
    });

    startButton.addEventListener('click', resetGame);
    restartButton.addEventListener('click', resetGame);
    playAgainButton.addEventListener('click', resetGame);
    nextLevelButton.addEventListener('click', () => loadLevel(currentLevel + 1));

    window.onload = function() {
        updateUI();
        initCompetitors();
        requestAnimationFrame(gameLoop);
    };
</script>

</body>
</html>